//! # rltbl/rltbl_db

use indexmap::IndexMap;
use lazy_static::lazy_static;
use regex::Regex;
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use serde_json::Map as JsonMap;
use std::fmt::Display;
use std::future::Future;

pub type JsonValue = serde_json::Value;
pub type JsonRow = JsonMap<String, JsonValue>;
pub type StringRow = IndexMap<String, String>;
pub type ColumnMap = IndexMap<String, String>;

/// Represents a valid database table name.
static VALID_TABLE_NAME_MATCH_STR: &str = r"^[A-Za-z_][0-9A-Za-z_]*$";

lazy_static! {
    /// The regex used to match [valid database table names](VALID_TABLE_NAME_MATCH_STR).
    static ref VALID_TABLE_NAME_REGEX: Regex = Regex::new(VALID_TABLE_NAME_MATCH_STR).unwrap();
}

/// Convert a JSON Value to a String,
/// without quoting for JSON Value::String,
/// and treating JSON Value::Null as "NULL".
pub fn json_value_to_string(value: &JsonValue) -> String {
    match value {
        JsonValue::String(string) => string.to_string(),
        JsonValue::Null => "NULL".to_string(),
        _ => value.to_string(),
    }
}

/// Convert a row of JSON Values to a row of Strings.
pub fn json_row_to_string_row(row: &JsonRow) -> StringRow {
    row.iter()
        .map(|(key, value)| (key.clone(), json_value_to_string(value)))
        .collect()
}

/// Convert a vector of JSON rows to a vector of String rows.
pub fn json_rows_to_string_rows(rows: &[JsonRow]) -> Vec<StringRow> {
    rows.iter().map(|row| json_row_to_string_row(row)).collect()
}

/// Defines the supported database kinds.
#[derive(Clone, Copy, Debug, Deserialize, Serialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum DbKind {
    SQLite,
    PostgreSQL,
}

impl Display for DbKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DbKind::SQLite => write!(f, "SQLite"),
            DbKind::PostgreSQL => write!(f, "PostgreSQL"),
        }
    }
}

/// Defines the various error types that can be generated by rltbl_db.
#[derive(Clone, Debug)]
#[non_exhaustive] // We may add more specific error types in the future.
pub enum DbError {
    /// An error that occurred while connecting to a database.
    ConnectError(String),
    /// An error in the arguments to a function that accessed the database.
    InputError(String),
    /// An error in the data retrieved from the database.
    DataError(String),
    /// An error that originated from the database.
    DatabaseError(String),
    /// An error with the data type of a value.
    DatatypeError(String),
}

impl std::error::Error for DbError {}

impl std::fmt::Display for DbError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            DbError::ConnectError(err)
            | DbError::DataError(err)
            | DbError::InputError(err)
            | DbError::DatabaseError(err)
            | DbError::DatatypeError(err) => write!(f, "{err}"),
        }
    }
}

/// Value types for [query parameters](Params)
#[derive(Debug, Clone, Deserialize, Serialize)]
pub enum ParamValue {
    /// Represents a NULL value. Can be used with any column type.
    Null,
    /// Use with BOOL column types or equivalent.
    Boolean(bool),
    /// Use with INT2 column types or equivalent.
    SmallInteger(i16),
    /// Use with INT4 column types or equivalent.
    Integer(i32),
    /// Use with INT8 column types or equivalent.
    BigInteger(i64),
    /// Use with FLOAT4 column types or equivalent.
    Real(f32),
    /// Use with FLOAT8 column types or equivalent.
    BigReal(f64),
    /// Use with NUMERIC column types or equivalent.
    Numeric(Decimal),
    /// Use with TEXT and VARCHAR column types or equivalent.
    Text(String),
}

impl Into<String> for ParamValue {
    fn into(self) -> String {
        match self {
            ParamValue::Null => String::new(),
            ParamValue::Boolean(val) => val.to_string(),
            ParamValue::SmallInteger(number) => number.to_string(),
            ParamValue::Integer(number) => number.to_string(),
            ParamValue::BigInteger(number) => number.to_string(),
            ParamValue::Real(number) => number.to_string(),
            ParamValue::BigReal(number) => number.to_string(),
            ParamValue::Numeric(decimal) => decimal.to_string(),
            ParamValue::Text(string) => string.to_string(),
        }
    }
}

impl Into<String> for &ParamValue {
    fn into(self) -> String {
        self.clone().into()
    }
}

// Implementations of attempted conversions of various types into ParamValues:

impl From<&str> for ParamValue {
    fn from(item: &str) -> Self {
        ParamValue::Text(item.to_string())
    }
}

impl From<String> for ParamValue {
    fn from(item: String) -> Self {
        ParamValue::Text(item)
    }
}

impl From<&String> for ParamValue {
    fn from(item: &String) -> Self {
        ParamValue::Text(item.clone())
    }
}

impl From<i16> for ParamValue {
    fn from(item: i16) -> Self {
        ParamValue::SmallInteger(item)
    }
}

impl From<i32> for ParamValue {
    fn from(item: i32) -> Self {
        ParamValue::Integer(item.into())
    }
}

impl From<i64> for ParamValue {
    fn from(item: i64) -> Self {
        ParamValue::BigInteger(item)
    }
}

impl From<u16> for ParamValue {
    fn from(item: u16) -> Self {
        ParamValue::Integer(item.into())
    }
}

impl From<u32> for ParamValue {
    fn from(item: u32) -> Self {
        if usize::BITS <= 31 {
            ParamValue::Integer(item as i32)
        } else {
            ParamValue::BigInteger(item as i64)
        }
    }
}

impl From<u64> for ParamValue {
    fn from(item: u64) -> Self {
        if item <= i64::MAX as u64 {
            ParamValue::BigInteger(item as i64)
        } else {
            ParamValue::Numeric(Decimal::from(item))
        }
    }
}

impl From<isize> for ParamValue {
    fn from(item: isize) -> Self {
        if isize::BITS <= 32 {
            ParamValue::Integer(item as i32)
        } else if isize::BITS <= 64 {
            ParamValue::BigInteger(item as i64)
        } else {
            ParamValue::Numeric(Decimal::from(item))
        }
    }
}

impl From<usize> for ParamValue {
    fn from(item: usize) -> Self {
        if usize::BITS <= 31 {
            ParamValue::Integer(item as i32)
        } else if usize::BITS <= 63 {
            ParamValue::BigInteger(item as i64)
        } else {
            ParamValue::Numeric(Decimal::from(item))
        }
    }
}

impl From<f32> for ParamValue {
    fn from(item: f32) -> Self {
        ParamValue::Real(item)
    }
}

impl From<f64> for ParamValue {
    fn from(item: f64) -> Self {
        ParamValue::BigReal(item)
    }
}

impl From<Decimal> for ParamValue {
    fn from(item: Decimal) -> Self {
        ParamValue::Numeric(item)
    }
}

impl From<bool> for ParamValue {
    fn from(item: bool) -> Self {
        ParamValue::Boolean(item)
    }
}

impl From<()> for ParamValue {
    fn from(_: ()) -> Self {
        ParamValue::Null
    }
}

// f32 and f64 don't implement PartialEq, so we have to do it ourselves.
impl PartialEq for ParamValue {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (ParamValue::Null, ParamValue::Null) => true,
            (ParamValue::Boolean(a), ParamValue::Boolean(b)) => a == b,
            (ParamValue::SmallInteger(a), ParamValue::SmallInteger(b)) => a == b,
            (ParamValue::Integer(a), ParamValue::Integer(b)) => a == b,
            (ParamValue::BigInteger(a), ParamValue::BigInteger(b)) => a == b,
            (ParamValue::Real(a), ParamValue::Real(b)) => {
                if a.is_finite() && b.is_finite() {
                    a == b
                } else {
                    false
                }
            }
            (ParamValue::BigReal(a), ParamValue::BigReal(b)) => {
                if a.is_finite() && b.is_finite() {
                    a == b
                } else {
                    false
                }
            }
            (ParamValue::Numeric(a), ParamValue::Numeric(b)) => a == b,
            (ParamValue::Text(a), ParamValue::Text(b)) => a == b,
            _ => false,
        }
    }
}

impl Eq for ParamValue {}

impl ParamValue {
    /// Convert a serde_json Value to a ParamValue.
    pub fn from_json(value: JsonValue) -> Self {
        match &value {
            JsonValue::Null => Self::Null,
            JsonValue::Bool(val) => Self::Boolean(*val),
            JsonValue::Number(number) => {
                if number.is_u64() {
                    Self::from(number.as_u64().unwrap())
                } else if number.is_i64() {
                    Self::from(number.as_i64().unwrap())
                } else if number.is_f64() {
                    Self::BigReal(number.as_f64().unwrap())
                } else {
                    Self::Text(value.to_string())
                }
            }
            JsonValue::String(string) => Self::Text(string.to_string()),
            JsonValue::Array(_) => Self::Text(value.to_string()),
            JsonValue::Object(_) => Self::Text(value.to_string()),
        }
    }
}

pub trait IntoParamValue {
    fn into_param_value(self) -> ParamValue;
}

/// Implements [IntoParamValue] for types that implement [TryFrom] for [ParamValue].
impl<T: Into<ParamValue>> IntoParamValue for T {
    fn into_param_value(self) -> ParamValue {
        self.into()
    }
}

/// Query parameters
#[derive(Debug, Clone)]
pub enum Params {
    None,
    Positional(Vec<ParamValue>),
}

/// Types that implement this trait can be converted into [Params]
pub trait IntoParams {
    fn into_params(self) -> Params;
}

/// (Trivially) implements [IntoParams] for [Params]
impl IntoParams for Params {
    fn into_params(self) -> Params {
        self
    }
}

/// Implements [IntoParams] for references to [Params]
impl IntoParams for &Params {
    fn into_params(self) -> Params {
        self.clone()
    }
}

/// Implements [IntoParams] for an empty tuple. Always returns [Params::None].
impl IntoParams for () {
    fn into_params(self) -> Params {
        Params::None
    }
}

/// Implements [IntoParams] for fixed-length arrays of types that implement [IntoParamValue]
impl<T: IntoParamValue, const N: usize> IntoParams for [T; N] {
    fn into_params(self) -> Params {
        self.into_iter().collect::<Vec<_>>().into_params()
    }
}

/// Implements [IntoParams] for references to fixed-length arrays of types that implement
/// [IntoParamValue]
impl<T: IntoParamValue + Clone, const N: usize> IntoParams for &[T; N] {
    fn into_params(self) -> Params {
        self.iter().cloned().collect::<Vec<_>>().into_params()
    }
}

/// Implements [IntoParams] for vectors of types that implement [IntoParamValue]
impl<T: IntoParamValue> IntoParams for Vec<T> {
    fn into_params(self) -> Params {
        let values = self
            .into_iter()
            .map(|i| i.into_param_value())
            .collect::<Vec<_>>();
        Params::Positional(values)
    }
}

/// Converts a list of assorted types implementing [IntoParamValue] into [Params]
#[macro_export]
macro_rules! params {
    () => {
       ()
    };
    ($($value:expr),* $(,)?) => {{
        use $crate::core::IntoParamValue;
        [$($value.into_param_value()),*]

    }};
}

pub trait DbQuery {
    /// Get the kind of SQL database: SQLite or PostgreSQL.
    fn kind(&self) -> DbKind;

    /// Given a SQL type for this database and a string,
    /// parse the string into the right ParamValue.
    fn parse(&self, sql_type: &str, value: &str) -> Result<ParamValue, DbError>;

    /// Given a SQL type for this database and a JSON Value,
    /// convert the Value into the right ParamValue.
    fn convert_json(&self, sql_type: &str, value: &JsonValue) -> Result<ParamValue, DbError>;

    /// Given a table, return a map from column names to column SQL types.
    fn columns(&self, table: &str) -> impl Future<Output = Result<ColumnMap, DbError>> + Send;

    // TODO: Consider combining this function with columns().
    /// Retrieve the primary key columns for a given table.
    fn keys(&self, table: &str) -> impl Future<Output = Result<Vec<String>, DbError>> + Send;

    /// Execute a SQL command, without a return value.
    fn execute(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<(), DbError>> + Send;

    /// Sequentially execute a semicolon-delimited list of statements, without parameters.
    fn execute_batch(&self, sql: &str) -> impl Future<Output = Result<(), DbError>> + Send;

    /// Execute a SQL command, returning a vector of JSON rows.
    fn query(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<Vec<JsonRow>, DbError>> + Send;

    /// Execute a SQL command, returning a single JSON row.
    fn query_row(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<JsonRow, DbError>> + Send;

    /// Execute a SQL command, returning a single JSON value.
    fn query_value(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<JsonValue, DbError>> + Send;

    /// Execute a SQL command, returning a single string.
    fn query_string(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<String, DbError>> + Send;

    /// Execute a SQL command, returning a vector of strings: the first value for each row.
    fn query_strings(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<Vec<String>, DbError>> + Send;

    /// Execute a SQL command, returning a row of strings.
    fn query_string_row(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<StringRow, DbError>> + Send;

    /// Execute a SQL command, returning a vector of rows of strings.
    fn query_string_rows(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<Vec<StringRow>, DbError>> + Send;

    /// Execute a SQL command, returning a single unsigned integer.
    fn query_u64(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<u64, DbError>> + Send;

    /// Execute a SQL command, returning a single signed integer.
    fn query_i64(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<i64, DbError>> + Send;

    /// Execute a SQL command, returning a single float.
    fn query_f64(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<f64, DbError>> + Send;

    /// Insert JSON rows into the given table. If an input row does not have a key for a column,
    /// use NULL as the value of that column when inserting the row to the table.
    fn insert(
        &self,
        table: &str,
        columns: &[&str],
        rows: &[&JsonRow],
    ) -> impl Future<Output = Result<(), DbError>>;

    /// Insert the given JSON rows into the given table, and then return the columns from the
    /// inserted data that are included in `returning`, or all of the inserted data if `returning`
    /// is an empty list. If an input row does not have a key for a column, use NULL as the value
    /// of that column when inserting the row to the table.
    fn insert_returning(
        &self,
        table: &str,
        columns: &[&str],
        rows: &[&JsonRow],
        returning: &[&str],
    ) -> impl Future<Output = Result<Vec<JsonRow>, DbError>>;

    /// TODO: Add docstring
    fn update(&self, table: &str, rows: &[&JsonRow]) -> impl Future<Output = Result<(), DbError>>;

    /// TODO: Add docstring
    fn update_returning(
        &self,
        table: &str,
        rows: &[&JsonRow],
        returning: &[&str],
    ) -> impl Future<Output = Result<Vec<JsonRow>, DbError>>;

    /// Drop the given table from the database.
    fn drop_table(&self, table: &str) -> impl Future<Output = Result<(), DbError>>;
}

/// Determines whether the given table name is a valid database table name. Valid database table
/// names must match the regular expression: `^[A-Za-z_\]\[0-9A-Za-z_]*$`. For convenience, a
/// double-quoted valid table name is also accepted as valid. The function returns the table name,
/// if valid, with the surrounding double-quotes (if any) removed, or an error if the table name is
/// invalid.
pub fn validate_table_name(table_name: &str) -> Result<String, DbError> {
    let error_msg = format!(
        "Not a valid table name: \"{table_name}\". Valid table names must match \
         the regular expression: '{VALID_TABLE_NAME_MATCH_STR}' and may possibly begin and \
         end with double-quotes."
    );
    let table_name = match table_name.strip_prefix("\"") {
        Some(table_name) => match table_name.strip_suffix("\"") {
            Some(table_name) => table_name,
            None => return Err(DbError::InputError(error_msg)),
        },
        None => match table_name.strip_suffix("\"") {
            Some(_) => return Err(DbError::InputError(error_msg)),
            None => table_name,
        },
    };
    match VALID_TABLE_NAME_REGEX.is_match(table_name) {
        true => Ok(table_name.to_string()),
        false => Err(DbError::InputError(error_msg)),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_table_names() {
        // Valid table names:
        assert_eq!(
            validate_table_name(r#"table"#).expect("Expected table name to be valid"),
            "table"
        );
        assert_eq!(
            validate_table_name(r#"my_table"#).expect("Expected table name to be valid"),
            "my_table"
        );
        assert_eq!(
            validate_table_name(r#"my_2nd_table"#).expect("Expected table name to be valid"),
            "my_2nd_table"
        );
        assert_eq!(
            validate_table_name(r#"my_table_2"#).expect("Expected table name to be valid"),
            "my_table_2"
        );
        assert_eq!(
            validate_table_name(r#"my_table2"#).expect("Expected table name to be valid"),
            "my_table2"
        );
        assert_eq!(
            validate_table_name(r#"My_Table_2"#).expect("Expected table name to be valid"),
            "My_Table_2"
        );

        // Valid table name surrounded by quotes:
        assert_eq!(
            validate_table_name(r#""table""#).expect("Expected table name to be valid"),
            "table"
        );

        // Invalid first character:
        if let Ok(_) = validate_table_name(r#"1table"#) {
            panic!("Expected an error");
        };
        if let Ok(_) = validate_table_name(r#""1table""#) {
            panic!("Expected an error");
        }

        // Beginning or trailing double-quote is missing:
        if let Ok(_) = validate_table_name(r#"table""#) {
            panic!("Expected an error");
        }
        if let Ok(_) = validate_table_name(r#""table"#) {
            panic!("Expected an error");
        }

        // Table name with spaces:
        if let Ok(_) = validate_table_name(r#"my table"#) {
            panic!("Expected an error");
        }
    }
}
