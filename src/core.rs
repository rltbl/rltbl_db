//! # rltbl/rltbl_db

use async_trait::async_trait;
use indexmap::IndexMap;
use lazy_static::lazy_static;
use rand::seq::SliceRandom;
use regex::Regex;
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use serde_json::{Map as JsonMap, json};
use std::{
    collections::{HashMap, HashSet},
    fmt::Display,
    future::Future,
    str::FromStr,
    sync::Mutex,
};

pub type JsonValue = serde_json::Value;
pub type JsonRow = JsonMap<String, JsonValue>;
pub type StringRow = IndexMap<String, String>;
pub type ColumnMap = IndexMap<String, String>;

/// Represents a valid database table name.
static VALID_TABLE_NAME_MATCH_STR: &str = r"^[A-Za-z_][0-9A-Za-z_]*$";

/// Default size for the in-memory cache
pub static DEFAULT_MEMORY_CACHE_SIZE: usize = 1000;

lazy_static! {
    /// The regex used to match [valid database table names](VALID_TABLE_NAME_MATCH_STR).
    static ref VALID_TABLE_NAME_REGEX: Regex = Regex::new(VALID_TABLE_NAME_MATCH_STR).unwrap();

    /// The in-memory cache.
    static ref MEMORY_CACHE: Mutex<HashMap<MemoryCacheKey, Vec<JsonRow>>> = Mutex::new(HashMap::new());
}

/// Defines the supported database kinds.
#[derive(Clone, Copy, Debug, Deserialize, Serialize, PartialEq, Eq, PartialOrd, Ord)]
pub enum DbKind {
    SQLite,
    PostgreSQL,
}

impl Display for DbKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            DbKind::SQLite => write!(f, "SQLite"),
            DbKind::PostgreSQL => write!(f, "PostgreSQL"),
        }
    }
}

/// Defines the various error types that can be generated by rltbl_db.
#[derive(Clone, Debug)]
#[non_exhaustive] // We may add more specific error types in the future.
pub enum DbError {
    /// An error that occurred while connecting to a database.
    ConnectError(String),
    /// An error in the arguments to a function that accessed the database.
    InputError(String),
    /// An error in the data retrieved from the database.
    DataError(String),
    /// An error that originated from the database.
    DatabaseError(String),
    /// An error with the data type of a value.
    DatatypeError(String),
}

impl std::error::Error for DbError {}

impl std::fmt::Display for DbError {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            DbError::ConnectError(err)
            | DbError::DataError(err)
            | DbError::InputError(err)
            | DbError::DatabaseError(err)
            | DbError::DatatypeError(err) => write!(f, "{err}"),
        }
    }
}

/// Value types for [query parameters](Params)
#[derive(Debug, Clone, Deserialize, Serialize)]
pub enum ParamValue {
    /// Represents a NULL value. Can be used with any column type.
    Null,
    /// Use with BOOL column types or equivalent.
    Boolean(bool),
    /// Use with INT2 column types or equivalent.
    SmallInteger(i16),
    /// Use with INT4 column types or equivalent.
    Integer(i32),
    /// Use with INT8 column types or equivalent.
    BigInteger(i64),
    /// Use with FLOAT4 column types or equivalent.
    Real(f32),
    /// Use with FLOAT8 column types or equivalent.
    BigReal(f64),
    /// Use with NUMERIC column types or equivalent.
    Numeric(Decimal),
    /// Use with TEXT and VARCHAR column types or equivalent.
    Text(String),
}

impl Into<String> for ParamValue {
    fn into(self) -> String {
        match self {
            ParamValue::Null => String::new(),
            ParamValue::Boolean(val) => val.to_string(),
            ParamValue::SmallInteger(number) => number.to_string(),
            ParamValue::Integer(number) => number.to_string(),
            ParamValue::BigInteger(number) => number.to_string(),
            ParamValue::Real(number) => number.to_string(),
            ParamValue::BigReal(number) => number.to_string(),
            ParamValue::Numeric(decimal) => decimal.to_string(),
            ParamValue::Text(string) => string.to_string(),
        }
    }
}

impl Into<String> for &ParamValue {
    fn into(self) -> String {
        self.clone().into()
    }
}

// Implementations of attempted conversions of various types into ParamValues:

impl From<&str> for ParamValue {
    fn from(item: &str) -> Self {
        ParamValue::Text(item.to_string())
    }
}

impl From<String> for ParamValue {
    fn from(item: String) -> Self {
        ParamValue::Text(item)
    }
}

impl From<&String> for ParamValue {
    fn from(item: &String) -> Self {
        ParamValue::Text(item.clone())
    }
}

impl From<i16> for ParamValue {
    fn from(item: i16) -> Self {
        ParamValue::SmallInteger(item)
    }
}

impl From<i32> for ParamValue {
    fn from(item: i32) -> Self {
        ParamValue::Integer(item.into())
    }
}

impl From<i64> for ParamValue {
    fn from(item: i64) -> Self {
        ParamValue::BigInteger(item)
    }
}

impl From<u16> for ParamValue {
    fn from(item: u16) -> Self {
        ParamValue::Integer(item.into())
    }
}

impl From<u32> for ParamValue {
    fn from(item: u32) -> Self {
        if usize::BITS <= 31 {
            ParamValue::Integer(item as i32)
        } else {
            ParamValue::BigInteger(item as i64)
        }
    }
}

impl From<u64> for ParamValue {
    fn from(item: u64) -> Self {
        if item <= i64::MAX as u64 {
            ParamValue::BigInteger(item as i64)
        } else {
            ParamValue::Numeric(Decimal::from(item))
        }
    }
}

impl From<isize> for ParamValue {
    fn from(item: isize) -> Self {
        if isize::BITS <= 32 {
            ParamValue::Integer(item as i32)
        } else if isize::BITS <= 64 {
            ParamValue::BigInteger(item as i64)
        } else {
            ParamValue::Numeric(Decimal::from(item))
        }
    }
}

impl From<usize> for ParamValue {
    fn from(item: usize) -> Self {
        if usize::BITS <= 31 {
            ParamValue::Integer(item as i32)
        } else if usize::BITS <= 63 {
            ParamValue::BigInteger(item as i64)
        } else {
            ParamValue::Numeric(Decimal::from(item))
        }
    }
}

impl From<f32> for ParamValue {
    fn from(item: f32) -> Self {
        ParamValue::Real(item)
    }
}

impl From<f64> for ParamValue {
    fn from(item: f64) -> Self {
        ParamValue::BigReal(item)
    }
}

impl From<Decimal> for ParamValue {
    fn from(item: Decimal) -> Self {
        ParamValue::Numeric(item)
    }
}

impl From<bool> for ParamValue {
    fn from(item: bool) -> Self {
        ParamValue::Boolean(item)
    }
}

impl From<()> for ParamValue {
    fn from(_: ()) -> Self {
        ParamValue::Null
    }
}

// f32 and f64 don't implement PartialEq, so we have to do it ourselves.
impl PartialEq for ParamValue {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (ParamValue::Null, ParamValue::Null) => true,
            (ParamValue::Boolean(a), ParamValue::Boolean(b)) => a == b,
            (ParamValue::SmallInteger(a), ParamValue::SmallInteger(b)) => a == b,
            (ParamValue::Integer(a), ParamValue::Integer(b)) => a == b,
            (ParamValue::BigInteger(a), ParamValue::BigInteger(b)) => a == b,
            (ParamValue::Real(a), ParamValue::Real(b)) => {
                if a.is_finite() && b.is_finite() {
                    a == b
                } else {
                    false
                }
            }
            (ParamValue::BigReal(a), ParamValue::BigReal(b)) => {
                if a.is_finite() && b.is_finite() {
                    a == b
                } else {
                    false
                }
            }
            (ParamValue::Numeric(a), ParamValue::Numeric(b)) => a == b,
            (ParamValue::Text(a), ParamValue::Text(b)) => a == b,
            _ => false,
        }
    }
}

impl Eq for ParamValue {}

impl ParamValue {
    /// Convert a serde_json Value to a ParamValue.
    pub fn from_json(value: JsonValue) -> Self {
        match &value {
            JsonValue::Null => Self::Null,
            JsonValue::Bool(val) => Self::Boolean(*val),
            JsonValue::Number(number) => {
                if number.is_u64() {
                    Self::from(number.as_u64().unwrap())
                } else if number.is_i64() {
                    Self::from(number.as_i64().unwrap())
                } else if number.is_f64() {
                    Self::BigReal(number.as_f64().unwrap())
                } else {
                    Self::Text(value.to_string())
                }
            }
            JsonValue::String(string) => Self::Text(string.to_string()),
            JsonValue::Array(_) => Self::Text(value.to_string()),
            JsonValue::Object(_) => Self::Text(value.to_string()),
        }
    }
}

pub trait IntoParamValue {
    fn into_param_value(self) -> ParamValue;
}

/// Implements [IntoParamValue] for types that implement [TryFrom] for [ParamValue].
impl<T: Into<ParamValue>> IntoParamValue for T {
    fn into_param_value(self) -> ParamValue {
        self.into()
    }
}

/// Query parameters
#[derive(Debug, Clone)]
pub enum Params {
    None,
    Positional(Vec<ParamValue>),
}

/// Types that implement this trait can be converted into [Params]
pub trait IntoParams {
    fn into_params(self) -> Params;
}

/// (Trivially) implements [IntoParams] for [Params]
impl IntoParams for Params {
    fn into_params(self) -> Params {
        self
    }
}

/// Implements [IntoParams] for references to [Params]
impl IntoParams for &Params {
    fn into_params(self) -> Params {
        self.clone()
    }
}

/// Implements [IntoParams] for an empty tuple. Always returns [Params::None].
impl IntoParams for () {
    fn into_params(self) -> Params {
        Params::None
    }
}

/// Implements [IntoParams] for fixed-length arrays of types that implement [IntoParamValue]
impl<T: IntoParamValue, const N: usize> IntoParams for [T; N] {
    fn into_params(self) -> Params {
        self.into_iter().collect::<Vec<_>>().into_params()
    }
}

/// Implements [IntoParams] for references to fixed-length arrays of types that implement
/// [IntoParamValue]
impl<T: IntoParamValue + Clone, const N: usize> IntoParams for &[T; N] {
    fn into_params(self) -> Params {
        self.iter().cloned().collect::<Vec<_>>().into_params()
    }
}

/// Implements [IntoParams] for vectors of types that implement [IntoParamValue]
impl<T: IntoParamValue> IntoParams for Vec<T> {
    fn into_params(self) -> Params {
        let values = self
            .into_iter()
            .map(|i| i.into_param_value())
            .collect::<Vec<_>>();
        Params::Positional(values)
    }
}

/// Converts a list of assorted types implementing [IntoParamValue] into [Params]
#[macro_export]
macro_rules! params {
    () => {
       ()
    };
    ($($value:expr),* $(,)?) => {{
        use $crate::core::IntoParamValue;
        [$($value.into_param_value()),*]

    }};
}

/// Strategy to use when caching query results
#[derive(Clone, Copy, Debug)]
pub enum CachingStrategy {
    None,
    TruncateAll,
    Truncate,
    Trigger,
    Memory(usize),
}

/// The structure used to look up query results in the in-memory cache:
#[derive(Clone, Eq, PartialEq, Hash)]
pub struct MemoryCacheKey {
    pub tables: String,
    pub statement: String,
    pub parameters: String,
}

impl FromStr for CachingStrategy {
    type Err = DbError;

    fn from_str(strategy: &str) -> Result<Self, DbError> {
        match strategy.to_lowercase().as_str() {
            "none" => Ok(CachingStrategy::None),
            "truncate_all" => Ok(CachingStrategy::TruncateAll),
            "truncate" => Ok(CachingStrategy::Truncate),
            "trigger" => Ok(CachingStrategy::Trigger),
            strategy if strategy.starts_with("memory") => {
                let elems = strategy.split(":").collect::<Vec<_>>();
                let cache_size = {
                    if elems.len() < 2 {
                        DEFAULT_MEMORY_CACHE_SIZE
                    } else {
                        let cache_size = elems[1];
                        match cache_size.parse::<usize>() {
                            Ok(0) => DEFAULT_MEMORY_CACHE_SIZE,
                            Ok(size) => size,
                            Err(err) => return Err(DbError::InputError(format!(
                                "Error parsing memory cache size specification: '{cache_size}': \
                                 {err}"
                            ))
                            .into()),
                        }
                    }
                };
                Ok(CachingStrategy::Memory(cache_size))
            }
            _ => {
                return Err(
                    DbError::InputError(format!("Unrecognized strategy: {strategy}")).into(),
                );
            }
        }
    }
}

impl Display for CachingStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            CachingStrategy::None => write!(f, "none"),
            CachingStrategy::TruncateAll => write!(f, "truncate_all"),
            CachingStrategy::Truncate => write!(f, "truncate"),
            CachingStrategy::Trigger => write!(f, "trigger"),
            CachingStrategy::Memory(size) => write!(f, "memory:{size}"),
        }
    }
}

#[async_trait]
pub trait DbQuery {
    /// Get the kind of SQL database: SQLite or PostgreSQL.
    fn kind(&self) -> DbKind;

    /// Set the caching strategy.
    fn set_caching_strategy(&mut self, strategy: &CachingStrategy);

    /// Get the current caching strategy.
    fn get_caching_strategy(&self) -> CachingStrategy;

    /// Ensure that the cache table exists
    fn ensure_cache_table_exists(&self) -> impl Future<Output = Result<(), DbError>> + Send;

    /// Ensure that caching triggers exist for the given tables. Note that this function calls
    /// [DbQuery::ensure_cache_table_exists()] implicitly.
    fn ensure_caching_triggers_exist(
        &self,
        tables: &[&str],
    ) -> impl Future<Output = Result<(), DbError>> + Send;

    /// Clear the cache entries for the given tables (if the cache table exists), or clear the whole
    /// cache if `tables` is an empty list.
    async fn clear_cache(&self, tables: &[&str]) -> Result<(), DbError> {
        match self.table_exists("cache").await? {
            false => Ok(()),
            true => match tables.is_empty() {
                true => {
                    self.execute(r#"DELETE FROM "cache""#, ()).await?;
                    Ok(())
                }
                false => {
                    let prefix = match self.kind() {
                        DbKind::SQLite => "?",
                        DbKind::PostgreSQL => "$",
                    };
                    for table in tables {
                        let table = format!(r#"%{table}%"#);
                        self.execute(
                            &format!(r#"DELETE FROM "cache" WHERE "tables" LIKE {prefix}1"#),
                            &[table],
                        )
                        .await?;
                    }
                    Ok(())
                }
            },
        }
    }

    /// Execute a SQL command, returning a vector of JSON rows. If the result of the command exists
    /// in the cache, get the value from it instead of from the table(s) actually mentioned in the
    /// command, using the given [CachingStrategy].
    async fn cache(
        &self,
        tables: &[&str],
        sql: &str,
        params: impl IntoParams + Send + Copy + Sync,
    ) -> Result<Vec<JsonRow>, DbError> {
        let db_cache =
            async |tables: &[&str], sql: &str, params: &Params| -> Result<Vec<JsonRow>, DbError> {
                // Look in the cache to see if there is an entry corresponding to the given SQL
                // string for the given tables and parameters. If so, return the data from the
                // cache, otherwise execute the given SQL statement on the actualy specified
                // tables.
                let tables_cast = match self.kind() {
                    DbKind::SQLite => r#"CAST("tables" AS TEXT)"#,
                    DbKind::PostgreSQL => r#""tables"::TEXT"#,
                };
                let prefix = match self.kind() {
                    DbKind::SQLite => "?",
                    DbKind::PostgreSQL => "$",
                };
                let cache_sql = format!(
                    r#"SELECT {prefix}1||rtrim(ltrim("value", '['), ']')||{prefix}2 AS "value"
                       FROM "cache"
                       WHERE {tables_cast} = {prefix}3
                       AND "statement" = {prefix}4
                       AND "parameters" = {prefix}5
                       LIMIT 1"#
                );
                let tables_param = format!("[{}]", tables.join(", "));
                let params_param = match params {
                    Params::None => "[]".to_string(),
                    Params::Positional(params) => {
                        let params = params.iter().map(|p| p.into()).collect::<Vec<String>>();
                        format!("[{}]", params.join(", "))
                    }
                };
                let cache_params = &["[", "]", &tables_param, sql, &params_param];

                match self.query_strings(&cache_sql, cache_params).await?.first() {
                    Some(values) => {
                        let json_rows: Vec<JsonRow> = match serde_json::from_str(&values) {
                            Ok(json_rows) => json_rows,
                            _ => {
                                return Err(DbError::DataError(format!(
                                    "Invalid cache values: {values}"
                                )));
                            }
                        };
                        Ok(json_rows)
                    }
                    None => {
                        let json_rows = self.query(sql, params).await?;
                        let json_rows_content = json!(json_rows).to_string();
                        let insert_sql = format!(
                            r#"INSERT INTO "cache"
                               ("tables", "statement", "parameters", "value")
                               VALUES ({prefix}1, {prefix}2, {prefix}3, {prefix}4)"#
                        );
                        let insert_params = [&tables_param, sql, &params_param, &json_rows_content];
                        self.query(&insert_sql, &insert_params).await?;
                        Ok(json_rows)
                    }
                }
            };

        let mem_cache = async |tables: &[&str],
                               sql: &str,
                               params: &Params,
                               cache_size: usize|
               -> Result<Vec<JsonRow>, DbError> {
            let params = &params.into_params();
            let mem_key = MemoryCacheKey {
                tables: tables.join(", ").to_string(),
                statement: sql.to_string(),
                parameters: format!("{params:?}"),
            };
            let cached_rows = {
                let cache = match MEMORY_CACHE.try_lock() {
                    Ok(cache) => cache,
                    Err(err) => {
                        return Err(DbError::ConnectError(format!("Error locking cache: {err}")));
                    }
                };
                match cache.get(&mem_key) {
                    Some(json_rows) => Some(json_rows.to_vec()),
                    None => None,
                }
            };
            match cached_rows {
                Some(json_rows) => Ok(json_rows),
                None => {
                    let json_rows = self.query(sql, params).await?;
                    let mut cache = match MEMORY_CACHE.try_lock() {
                        Ok(cache) => cache,
                        Err(err) => {
                            return Err(DbError::ConnectError(format!(
                                "Error locking cache: {err}"
                            )));
                        }
                    };
                    let mut keys = cache.keys().map(|key| key.clone()).collect::<Vec<_>>();
                    // If the number of keys exceeds the allowed cache size, remove any extra keys
                    // at random.
                    if keys.len() >= cache_size {
                        keys.shuffle(&mut rand::rng());
                        for (i, key) in keys.iter().enumerate().rev() {
                            if i >= (cache_size - 1) {
                                cache.remove(&key);
                            } else {
                                break;
                            }
                        }
                    }
                    cache.insert(mem_key, json_rows.to_vec());
                    Ok(json_rows)
                }
            }
        };

        match self.get_caching_strategy() {
            CachingStrategy::None => self.query(sql, params).await,
            CachingStrategy::TruncateAll | CachingStrategy::Truncate => {
                self.ensure_cache_table_exists().await?;
                db_cache(tables, sql, &params.into_params()).await
            }
            CachingStrategy::Trigger => {
                self.ensure_caching_triggers_exist(tables).await?;
                db_cache(tables, sql, &params.into_params()).await
            }
            CachingStrategy::Memory(cache_size) => {
                let rows = mem_cache(tables, sql, &params.into_params(), cache_size).await?;
                Ok(rows)
            }
        }
    }

    /// Given a SQL type for this database and a string,
    /// parse the string into the right ParamValue.
    fn parse(&self, sql_type: &str, value: &str) -> Result<ParamValue, DbError>;

    /// Given a SQL type for this database and a JSON Value,
    /// convert the Value into the right ParamValue.
    fn convert_json(&self, sql_type: &str, value: &JsonValue) -> Result<ParamValue, DbError> {
        match value {
            serde_json::Value::Null => Ok(ParamValue::Null),
            _ => {
                let string = json_value_to_string(value);
                self.parse(sql_type, &string)
            }
        }
    }

    /// Given a table, return a map from column names to column SQL types.
    fn columns(&self, table: &str) -> impl Future<Output = Result<ColumnMap, DbError>> + Send;

    // TODO: Consider combining this function with columns().
    /// Retrieve the primary key columns for a given table.
    fn primary_keys(
        &self,
        table: &str,
    ) -> impl Future<Output = Result<Vec<String>, DbError>> + Send;

    /// Execute a SQL command, without a return value.
    async fn execute(&self, sql: &str, params: impl IntoParams + Send) -> Result<(), DbError> {
        let params = params.into_params();
        match params {
            Params::None => self.query(sql, ()).await?,
            _ => self.query(sql, params).await?,
        };
        Ok(())
    }

    /// Sequentially execute a semicolon-delimited list of statements, without parameters.
    fn execute_batch(&self, sql: &str) -> impl Future<Output = Result<(), DbError>> + Send;

    /// Execute a SQL command, returning a vector of JSON rows.
    fn query(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> impl Future<Output = Result<Vec<JsonRow>, DbError>> + Send;

    /// Execute a SQL command, returning a single JSON row.
    async fn query_row(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> Result<JsonRow, DbError> {
        let rows = self.query(&sql, params).await?;
        if rows.len() > 1 {
            return Err(DbError::DataError(
                "More than one row returned for query_row()".to_string(),
            ));
        }
        match rows.into_iter().next() {
            Some(row) => Ok(row),
            None => Err(DbError::DataError("No row found".to_string())),
        }
    }

    /// Execute a SQL command, returning a single JSON value.
    async fn query_value(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> Result<JsonValue, DbError> {
        let row = self.query_row(sql, params).await?;
        if row.len() > 1 {
            return Err(DbError::DataError(
                "More than one value returned for query_value()".to_string(),
            ));
        }
        match row.values().next() {
            Some(value) => Ok(value.clone()),
            None => Err(DbError::DataError("No values found".to_string())),
        }
    }

    /// Execute a SQL command, returning a single string.
    async fn query_string(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> Result<String, DbError> {
        let value = self.query_value(sql, params).await?;
        Ok(json_value_to_string(&value))
    }

    /// Execute a SQL command, returning a vector of strings: the first value for each row.
    async fn query_strings(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> Result<Vec<String>, DbError> {
        let rows = self.query(sql, params).await?;
        rows.iter()
            .map(|row| match row.values().nth(0) {
                Some(value) => Ok(json_value_to_string(value)),
                None => Err(DbError::DataError("Empty row".to_owned())),
            })
            .collect()
    }

    /// Execute a SQL command, returning a row of strings.
    async fn query_string_row(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> Result<StringRow, DbError> {
        let row = self.query_row(sql, params).await?;
        Ok(json_row_to_string_row(&row))
    }

    /// Execute a SQL command, returning a vector of rows of strings.
    async fn query_string_rows(
        &self,
        sql: &str,
        params: impl IntoParams + Send,
    ) -> Result<Vec<StringRow>, DbError> {
        let rows = self.query(sql, params).await?;
        Ok(json_rows_to_string_rows(&rows))
    }

    /// Execute a SQL command, returning a single unsigned integer.
    async fn query_u64(&self, sql: &str, params: impl IntoParams + Send) -> Result<u64, DbError> {
        let value = self.query_value(sql, params).await?;
        match value.as_u64() {
            Some(val) => Ok(val),
            None => Err(DbError::DataError(format!(
                "Not an unsigned integer: {value}"
            ))),
        }
    }

    /// Execute a SQL command, returning a single signed integer.
    async fn query_i64(&self, sql: &str, params: impl IntoParams + Send) -> Result<i64, DbError> {
        let value = self.query_value(sql, params).await?;
        match value.as_i64() {
            Some(val) => Ok(val),
            None => Err(DbError::DataError(format!("Not an integer: {value}"))),
        }
    }

    /// Execute a SQL command, returning a single float.
    async fn query_f64(&self, sql: &str, params: impl IntoParams + Send) -> Result<f64, DbError> {
        let value = self.query_value(sql, params).await?;
        match value.as_f64() {
            Some(val) => Ok(val),
            None => Err(DbError::DataError(format!("Not an float: {value}"))),
        }
    }

    /// Insert JSON rows into the given table. If an input row does not have a key for a column,
    /// use NULL as the value of that column when inserting the row to the table.
    fn insert(
        &self,
        table: &str,
        columns: &[&str],
        rows: &[&JsonRow],
    ) -> impl Future<Output = Result<(), DbError>>;

    /// Like [DbQuery::insert()], but in addition this function also returns the columns from the
    /// inserted data that are included in `returning`, or all of the inserted data if `returning`
    /// is an empty list.
    fn insert_returning(
        &self,
        table: &str,
        columns: &[&str],
        rows: &[&JsonRow],
        returning: &[&str],
    ) -> impl Future<Output = Result<Vec<JsonRow>, DbError>>;

    /// Update the given table using the given JSON rows. The table should have a primary key
    /// and any columns included in the primary key should be present within each input row.
    /// The primary key column values will be used as a way of identifying the rows to update,
    /// while the other columns in the row will be updated to the given new values.
    fn update(
        &self,
        table: &str,
        columns: &[&str],
        rows: &[&JsonRow],
    ) -> impl Future<Output = Result<(), DbError>>;

    /// Like [DbQuery::update()], but in addition this function also returns the columns from the
    /// updated data that are included in `returning`, or all of the updated data if `returning`
    /// is an empty list.
    fn update_returning(
        &self,
        table: &str,
        columns: &[&str],
        rows: &[&JsonRow],
        returning: &[&str],
    ) -> impl Future<Output = Result<Vec<JsonRow>, DbError>>;

    /// Attempt to insert the given rows to the given table, similarly to [DbQuery::insert()].
    /// In case there is a conflict, update the table instead, similarly to [DbQuery::update()].
    fn upsert(
        &self,
        table: &str,
        columns: &[&str],
        rows: &[&JsonRow],
    ) -> impl Future<Output = Result<(), DbError>>;

    /// Like [DbQuery::upsert()], but in addition this function also returns the columns from the
    /// upserted data that are included in `returning`, or all of the upserted data if `returning`
    /// is an empty list.
    fn upsert_returning(
        &self,
        table: &str,
        columns: &[&str],
        rows: &[&JsonRow],
        returning: &[&str],
    ) -> impl Future<Output = Result<Vec<JsonRow>, DbError>>;

    /// Check whether the given table exists in the database.
    fn table_exists(&self, table: &str) -> impl Future<Output = Result<bool, DbError>> + Send;

    /// Drop the given table from the database. Note that for PostgreSQL (see
    /// <https://www.postgresql.org/docs/current/sql-droptable.html>), in the case of a
    /// dependent foreign key constraint, only the constraint will be removed, not the dependent
    /// table itself.
    async fn drop_table(&self, table: &str) -> Result<(), DbError> {
        let table = validate_table_name(table)?;
        // Drop the table:
        match self.kind() {
            DbKind::PostgreSQL => {
                self.execute(&format!(r#"DROP TABLE IF EXISTS "{table}" CASCADE"#), ())
                    .await?
            }
            DbKind::SQLite => {
                self.execute(&format!(r#"DROP TABLE IF EXISTS "{table}""#), ())
                    .await?
            }
        };

        // Delete dirty entries from the cache in accordance with our caching strategy:
        match self.get_caching_strategy() {
            CachingStrategy::None => (),
            CachingStrategy::TruncateAll => {
                self.clear_cache(&[]).await?;
            }
            // We clear the cache also in the case of a trigger, since the trigger will not
            // be triggered when we drop the table (it will, rather, be dropped along with the
            // table)
            CachingStrategy::Truncate | CachingStrategy::Trigger => {
                self.clear_cache(&[&table]).await?;
            }
            CachingStrategy::Memory(_) => clear_mem_cache(&[&table])?,
        };
        Ok(())
    }
}

/// Convert a JSON Value to a String,
/// without quoting for JSON Value::String,
/// and treating JSON Value::Null as "NULL".
pub fn json_value_to_string(value: &JsonValue) -> String {
    match value {
        JsonValue::String(string) => string.to_string(),
        JsonValue::Null => "NULL".to_string(),
        _ => value.to_string(),
    }
}

/// Convert a row of JSON Values to a row of Strings.
pub fn json_row_to_string_row(row: &JsonRow) -> StringRow {
    row.iter()
        .map(|(key, value)| (key.clone(), json_value_to_string(value)))
        .collect()
}

/// Convert a vector of JSON rows to a vector of String rows.
pub fn json_rows_to_string_rows(rows: &[JsonRow]) -> Vec<StringRow> {
    rows.iter().map(|row| json_row_to_string_row(row)).collect()
}

/// Determines whether the given table name is a valid database table name. Valid database table
/// names must match the regular expression: `^[A-Za-z_\]\[0-9A-Za-z_]*$`. For convenience, a
/// double-quoted valid table name is also accepted as valid. The function returns the table name,
/// if valid, with the surrounding double-quotes (if any) removed, or an error if the table name is
/// invalid.
pub fn validate_table_name(table_name: &str) -> Result<String, DbError> {
    let error_msg = format!(
        "Not a valid table name: \"{table_name}\". Valid table names must match \
         the regular expression: '{VALID_TABLE_NAME_MATCH_STR}' and may possibly begin and \
         end with double-quotes."
    );
    let table_name = match table_name.strip_prefix("\"") {
        Some(table_name) => match table_name.strip_suffix("\"") {
            Some(table_name) => table_name,
            None => return Err(DbError::InputError(error_msg)),
        },
        None => match table_name.strip_suffix("\"") {
            Some(_) => return Err(DbError::InputError(error_msg)),
            None => table_name,
        },
    };
    match VALID_TABLE_NAME_REGEX.is_match(table_name) {
        true => Ok(table_name.to_string()),
        false => Err(DbError::InputError(error_msg)),
    }
}

/// Clear the memory cache.
pub fn clear_mem_cache(tables: &[&str]) -> Result<(), DbError> {
    let mut cache = match MEMORY_CACHE.try_lock() {
        Ok(cache) => cache,
        Err(err) => {
            return Err(DbError::ConnectError(format!("Error locking cache: {err}")));
        }
    };
    let keys = cache
        .keys()
        .map(|k| k)
        .cloned()
        .collect::<HashSet<_>>()
        .into_iter()
        .collect::<Vec<_>>();
    for table in tables {
        for key in keys.iter() {
            if key.tables.contains(table) {
                cache.remove(key);
            }
        }
    }
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_table_names() {
        // Valid table names:
        assert_eq!(
            validate_table_name(r#"table"#).expect("Expected table name to be valid"),
            "table"
        );
        assert_eq!(
            validate_table_name(r#"my_table"#).expect("Expected table name to be valid"),
            "my_table"
        );
        assert_eq!(
            validate_table_name(r#"my_2nd_table"#).expect("Expected table name to be valid"),
            "my_2nd_table"
        );
        assert_eq!(
            validate_table_name(r#"my_table_2"#).expect("Expected table name to be valid"),
            "my_table_2"
        );
        assert_eq!(
            validate_table_name(r#"my_table2"#).expect("Expected table name to be valid"),
            "my_table2"
        );
        assert_eq!(
            validate_table_name(r#"My_Table_2"#).expect("Expected table name to be valid"),
            "My_Table_2"
        );

        // Valid table name surrounded by quotes:
        assert_eq!(
            validate_table_name(r#""table""#).expect("Expected table name to be valid"),
            "table"
        );

        // Invalid first character:
        if let Ok(_) = validate_table_name(r#"1table"#) {
            panic!("Expected an error");
        };
        if let Ok(_) = validate_table_name(r#""1table""#) {
            panic!("Expected an error");
        }

        // Beginning or trailing double-quote is missing:
        if let Ok(_) = validate_table_name(r#"table""#) {
            panic!("Expected an error");
        }
        if let Ok(_) = validate_table_name(r#""table"#) {
            panic!("Expected an error");
        }

        // Table name with spaces:
        if let Ok(_) = validate_table_name(r#"my table"#) {
            panic!("Expected an error");
        }
    }
}
